import prisma from '../db/prisma';
import { AIService } from './ai.service';
import { v4 as uuidv4 } from 'uuid';

const LEGAL_DISCLAIMER = `
⚠️ IMPORTANT DISCLAIMER ⚠️

This prediction is generated by artificial intelligence based on patterns detected in your historical data. It is NOT a guarantee, professional advice, or certainty about future events.

• Predictions are probabilistic estimates only
• Life is influenced by countless unpredictable factors
• Past patterns do not determine future outcomes
• This tool is for entertainment and reflection purposes
• Do not make major life decisions based solely on these predictions
• Consult appropriate professionals for important decisions

By viewing this prediction, you acknowledge that Lifeline and its creators bear no liability for prediction accuracy or decisions made based on predictions.
`.trim();

export class PredictiveAnalyticsService {
    /**
     * Generate all predictions for a user
     */
    static async generatePredictions(userId: string): Promise<any[]> {
        // Check if user has accepted disclaimer and enabled predictions
        const privacy = await prisma.patternPrivacy.findUnique({
            where: { userId },
        });

        if (!privacy?.enablePredictions || !privacy?.acceptedPredictionDisclaimer) {
            throw new Error('User must accept prediction disclaimer first');
        }

        // Get user's patterns
        const patterns = await prisma.pattern.findMany({
            where: {
                userId,
                confidenceScore: { gte: 60 }, // Only use high-confidence patterns
            },
            include: {
                events: {
                    include: {
                        biographyEvent: true,
                    },
                },
            },
        });

        const predictions = [];

        for (const pattern of patterns) {
            if (pattern.type === 'CAREER') {
                const prediction = await this.predictNextCareerMove(userId, pattern);
                if (prediction) predictions.push(prediction);
            }
            // Add other prediction types as needed
        }

        return predictions;
    }

    /**
     * Predict next career move based on pattern
     */
    static async predictNextCareerMove(userId: string, pattern: any) {
        const events = pattern.events.sort((a: any, b: any) =>
            new Date(a.eventDate).getTime() - new Date(b.eventDate).getTime()
        );

        if (events.length < 2) return null;

        // Calculate average interval between career events
        const intervals = [];
        for (let i = 1; i < events.length; i++) {
            const prevDate = new Date(events[i - 1].eventDate);
            const currentDate = new Date(events[i].eventDate);
            const diffMonths = this.monthsDifference(prevDate, currentDate);
            intervals.push(diffMonths);
        }

        const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
        const stdDev = this.calculateStdDev(intervals);

        // Predict next event date
        const lastEventDate = new Date(events[events.length - 1].eventDate);
        const predictedDate = new Date(lastEventDate);
        predictedDate.setMonth(predictedDate.getMonth() + Math.round(avgInterval));

        // Calculate confidence interval
        const confidenceLow = Math.round(avgInterval - stdDev);
        const confidenceHigh = Math.round(avgInterval + stdDev);

        // Generate AI prediction reasoning
        const reasoning = await this.generateCareerPredictionReasoning(pattern, avgInterval);

        // Calculate confidence score (lower std dev = higher confidence)
        const confidenceScore = Math.max(30, Math.min(85, 85 - (stdDev / avgInterval) * 100));

        const prediction = await prisma.prediction.create({
            data: {
                userId,
                patternId: pattern.id,
                category: 'CAREER',
                prediction: `Based on your historical pattern, you may experience a career transition around ${this.formatDate(predictedDate)}`,
                reasoning,
                disclaimer: LEGAL_DISCLAIMER,
                predictedDate,
                dateRange: `${confidenceLow}-${confidenceHigh} months from last event`,
                timeframeStart: new Date(lastEventDate.getTime() + confidenceLow * 30 * 24 * 60 * 60 * 1000),
                timeframeEnd: new Date(lastEventDate.getTime() + confidenceHigh * 30 * 24 * 60 * 60 * 1000),
                confidenceScore: Math.round(confidenceScore),
                confidenceLow,
                confidenceHigh,
                isPremiumFeature: true,
                expiresAt: new Date(predictedDate.getTime() + 180 * 24 * 60 * 60 * 1000), // 6 months after predicted date
            },
        });

        return prediction;
    }

    /**
     * Generate AI reasoning for career prediction
     */
    private static async generateCareerPredictionReasoning(pattern: any, avgInterval: number): Promise<string> {
        const prompt = `Based on this career pattern:
Title: ${pattern.title}
Description: ${pattern.description}
Insights: ${pattern.insights}
Average interval: ${Math.round(avgInterval)} months

Generate 2-3 sentences explaining WHY this prediction makes sense based on the historical pattern. Be specific and data-driven but acknowledge uncertainty.`;

        try {
            const reasoning = await AIService.generateText(prompt);
            return reasoning.trim() + '\n\nNote: This is a probabilistic estimate based on historical patterns and should not be treated as certain.';
        } catch (error) {
            return `This prediction is based on your historical career cycle of approximately ${Math.round(avgInterval)} months between transitions. However, life circumstances and personal choices can significantly alter this timeline.`;
        }
    }

    /**
     * Update prediction accuracy after the predicted date has passed
     */
    static async updatePredictionAccuracy(predictionId: string, outcome: string, actualDate?: Date, userFeedback?: string) {
        const prediction = await prisma.prediction.findUnique({
            where: { id: predictionId },
        });

        if (!prediction) {
            throw new Error('Prediction not found');
        }

        // Calculate accuracy score if actual date is provided
        let accuracyScore = null;
        if (actualDate && prediction.predictedDate) {
            const predictedTime = prediction.predictedDate.getTime();
            const actualTime = actualDate.getTime();
            const monthsDiff = Math.abs(this.monthsDifference(prediction.predictedDate, actualDate));

            // Accuracy decreases with time difference
            accuracyScore = Math.max(0, 100 - (monthsDiff * 10));
        }

        await prisma.prediction.update({
            where: { id: predictionId },
            data: {
                outcome: outcome as any,
                actualDate,
                userFeedback,
                accuracyScore,
            },
        });
    }

    /**
     * Get user's prediction accuracy stats
     */
    static async getPredictionAccuracy(userId: string) {
        const predictions = await prisma.prediction.findMany({
            where: {
                userId,
                outcome: { not: 'PENDING' },
            },
        });

        if (predictions.length === 0) {
            return {
                totalPredictions: 0,
                accurateCount: 0,
                inaccurateCount: 0,
                partiallyAccurateCount: 0,
                avgAccuracyScore: 0,
            };
        }

        const accurateCount = predictions.filter(p => p.outcome === 'ACCURATE').length;
        const inaccurateCount = predictions.filter(p => p.outcome === 'INACCURATE').length;
        const partiallyAccurateCount = predictions.filter(p => p.outcome === 'PARTIALLY_ACCURATE').length;

        const scoresWithValues = predictions.filter(p => p.accuracyScore !== null);
        const avgAccuracyScore = scoresWithValues.length > 0
            ? scoresWithValues.reduce((sum, p) => sum + (p.accuracyScore || 0), 0) / scoresWithValues.length
            : 0;

        return {
            totalPredictions: predictions.length,
            accurateCount,
            inaccurateCount,
            partiallyAccurateCount,
            avgAccuracyScore: Math.round(avgAccuracyScore),
        };
    }

    /**
     * Calculate confidence interval for a prediction
     */
    static async calculateConfidenceInterval(prediction: any): Promise<{ low: number; high: number }> {
        return {
            low: prediction.confidenceLow || 0,
            high: prediction.confidenceHigh || 100,
        };
    }

    /**
     * Helper: Calculate months difference
     */
    private static monthsDifference(date1: Date, date2: Date): number {
        return (date2.getFullYear() - date1.getFullYear()) * 12 + (date2.getMonth() - date1.getMonth());
    }

    /**
     * Helper: Calculate standard deviation
     */
    private static calculateStdDev(values: number[]): number {
        const avg = values.reduce((a, b) => a + b, 0) / values.length;
        const variance = values.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / values.length;
        return Math.sqrt(variance);
    }

    /**
     * Helper: Format date for display
     */
    private static formatDate(date: Date): string {
        const month = date.toLocaleDateString('en-US', { month: 'long' });
        const year = date.getFullYear();
        return `${month} ${year}`;
    }

    /**
     * Get user predictions
     */
    static async getUserPredictions(userId: string, includeExpired: boolean = false) {
        const where: any = { userId };

        if (!includeExpired) {
            where.OR = [
                { expiresAt: null },
                { expiresAt: { gte: new Date() } },
            ];
        }

        return await prisma.prediction.findMany({
            where,
            include: {
                pattern: true,
            },
            orderBy: { predictedDate: 'asc' },
        });
    }
}
